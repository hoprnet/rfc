\rfcnumber{0006}
\rfctitle{HOPR Mixer}
\rfcdate{October 2025}
\rfcauthor{Tino Breddin (@tolbrino)}
\section{RFC-0006: HOPR Mixer}\label{rfc-0006-hopr-mixer}

\begin{itemize}
\tightlist
\item
  \textbf{RFC Number:} 0006
\item
  \textbf{Title:} HOPR Mixer
\item
  \textbf{Status:} Finalised
\item
  \textbf{Author(s):} Tino Breddin (@tolbrino)
\item
  \textbf{Created:} 2025-08-14
\item
  \textbf{Updated:} 2025-10-27
\item
  \textbf{Version:} v1.0.0 (Finalised)
\item
  \textbf{Supersedes:} none
\item
  \textbf{Related Links:}
  \href{../RFC-0002-mixnet-keywords/0002-mixnet-keywords.md}{RFC-0002},
  \href{../RFC-0004-hopr-packet-protocol/0004-hopr-packet-protocol.md}{RFC-0004}
\end{itemize}

\subsection{1. Abstract}\label{abstract}

This RFC describes the HOPR mixer component, a critical element of the
HOPR mixnet that introduces temporal mixing to break timing correlations
between incoming and outgoing packets. By applying random delays to
packets, the mixer effectively destroys temporal patterns that could
otherwise be exploited for traffic analysis attacks. This specification
details the mixer's design, implementation requirements, and integration
points to enable consistent implementations across different HOPR nodes
whilst balancing anonymity protection against latency and throughput
requirements.

\subsection{2. Motivation}\label{motivation}

In mixnets, simply forwarding packets through multiple hops is
insufficient to prevent traffic analysis attacks. Even with encrypted
packet contents and obscured routing paths, adversaries can correlate
packets by observing timing patterns. An observer monitoring network
traffic at multiple points can potentially link incoming and outgoing
packets based on their arrival and departure times. This technique is
known as timing correlation or an intersection attack.

Without temporal mixing, an adversary who observes a packet arriving at
node A at time \codebubble{t₁} and a packet leaving node A at time
\codebubble{t₂ ≈ t₁} can infer with high probability that these packets
are the same, thus tracking packets through the network and potentially
deanonymising communications.

The HOPR mixer addresses this attack vector by:

\begin{itemize}
\tightlist
\item
  \textbf{breaking temporal correlations}: introducing random delays
  between packet arrival and departure times, making timing-based
  correlation significantly more difficult
\item
  \textbf{configurable privacy-latency trade-offs}: providing tunable
  delay parameters to balance anonymity protection against performance
  requirements
\item
  \textbf{efficient implementation}: using a priority queue that
  maintains packet ordering by release time, enabling
  \codebubble{O(log n)} operations
\item
  \textbf{high-throughput support}: maintaining mixing effectiveness
  even under high packet rates
\end{itemize}

\subsection{3. Terminology}\label{terminology}

The keywords ``MUST'', ``MUST NOT'', ``REQUIRED'', ``SHALL'', ``SHALL
NOT'', ``SHOULD'', ``SHOULD NOT'', ``RECOMMENDED'', ``MAY'', and
``OPTIONAL'' in this document are to be interpreted as described in
{[}01{]} when, and only when, they appear in all capitals, as shown
here.

All terminology used in this document, including general mix network
concepts and HOPR-specific definitions, is provided in
\href{../RFC-0002-mixnet-keywords/0002-mixnet-keywords.md}{RFC-0002}.
That document serves as the authoritative reference for the terminology
and conventions adopted across the HOPR RFC series.

Additional mixer-specific terms include:

\emph{mixing delay}: A random time interval added to a packet's transit
time through a node to prevent timing correlation attacks.

\emph{release timestamp}: The calculated time at which a delayed packet
should be forwarded from the mixer.

\emph{mixing buffer}: A priority queue that holds packets ordered by
their release timestamps.

\subsection{4. Specification}\label{specification}

\subsubsection{4.1. Overview}\label{overview}

The HOPR mixer follows a flow-based design that is split into these
steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Accept packets from upstream components
\item
  Assign random delays to each packet
\item
  Store packets in a time-ordered buffer
\item
  Release packets when their delay expires
\end{enumerate}

\subsubsection{4.2. Configuration
Parameters}\label{configuration-parameters}

The mixer accepts the following configuration parameters that control
the delay distribution:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \codebubble{min\_delay}: minimum delay applied to packets (default: 0
  ms). This establishes the lower bound of the delay interval.
\item
  \codebubble{delay\_range}: the range from minimum to maximum delay
  (default: 200 ms). The maximum delay is \codebubble{min\_delay} +
  \codebubble{delay\_range}.
\end{enumerate}

The actual delay for each packet is randomly selected from a probability
distribution over the interval
\codebubble{[min\_delay, min\_delay + delay\_range]}. The default
implementation uses a uniform distribution, but implementations MAY
support additional distributions (e.g., exponential, Poisson) for
enhanced anonymity properties.

\subsubsection{4.3. Core Components}\label{core-components}

\paragraph{4.3.1. Delay Assignment}\label{delay-assignment}

When a packet arrives at the mixer, the following operations are
performed:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A random delay is generated using a cryptographically secure random
  number generator (CSPRNG)
\item
  The release timestamp is calculated as
  \codebubble{current\_time + random\_delay}
\item
  The packet is wrapped with its release timestamp metadata
\item
  The wrapped packet is inserted into the mixing buffer, ordered by
  release timestamp
\end{enumerate}

To generate a satisfactory random delay, the following conditions MUST
be met:

\begin{itemize}
\tightlist
\item
  MUST use a CSPRNG with sufficient entropy (at least 128 bits of
  entropy)
\item
  MUST generate independent delays per packet, with no correlation or
  reuse across packets
\item
  SHOULD use uniform distribution as the baseline; other distributions
  (e.g., exponential, Poisson) MAY be supported via configuration
\item
  MUST NOT leak information about delay values through timing side
  channels
\end{itemize}

Different mixing strategies produce different results. A uniform
distribution will provide a simple baseline that is easy to implement
and analyse. More advanced strategies like Poisson mixing (as used in
Loopix {[}02{]}) can provide stronger anonymity properties by making
packet timings less distinguishable from cover traffic patterns, but
require careful parameter tuning and integration with cover traffic
generation.

\paragraph{4.3.2. Mixing buffer}\label{mixing-buffer}

The mixer maintains packets in a data structure where:

\begin{itemize}
\tightlist
\item
  Packets are ordered by their release timestamps
\item
  The packet with the earliest release time is always at the top
\item
  Insertion and extraction operations have \codebubble{O(log n)}
  complexity
\item
  If multiple packets share the same \codebubble{release\_time}, the
  ordering MUST be stable FIFO by insertion sequence
\end{itemize}

This ensures efficient processing even under high-load conditions.

\subsubsection{4.4. Operational Behaviour}\label{operational-behaviour}

\paragraph{4.4.1. Packet processing flow}\label{packet-processing-flow}

Packet processing SHOULD use the following flow:

\begin{codebubbleenv}
1. Packet arrives at mixer via sender
2. Random delay is generated: delay ∈ [min_delay, min_delay + delay_range]
3. Release timestamp calculated: release_time = now() + delay
4. Packet wrapped with timestamp and inserted into buffer
5. Receiver woken if sleeping
5a. If the inserted packet has an earlier `release_time` than the current head, re-arm the timer to the new head
6. When current_time ≥ release_time, packet is released to Receiver
6a. Upon wake (including after system sleep), release all packets with `release_time` ≤ current_time before sleeping again
\end{codebubbleenv}

\paragraph{4.4.2. Timer Management}\label{timer-management}

The mixer requires a timer that is able to:

\begin{itemize}
\tightlist
\item
  Wake the mixer at the next packet's \codebubble{release\_time}
\item
  Use minimal system calls and context switches
\item
  Handle concurrent access safely
\item
  Use a monotonic clock source (not wall clock) for computing
  \codebubble{release\_time}
\item
  Handle system sleep/clock adjustments by releasing all overdue packets
  immediately upon wake
\end{itemize}

NOTE: The need for a dedicated timer MAY be satisfied automatically when
using an RTOS and its native waking mechanisms.

\subsubsection{4.5. Special Cases}\label{special-cases}

\paragraph{4.5.1. Zero Delay
Configuration}\label{zero-delay-configuration}

When both \codebubble{min\_delay} and \codebubble{delay\_range} are
zero:

\begin{itemize}
\tightlist
\item
  Packets pass through without mixing
\item
  Original packet order is preserved
\item
  Useful for testing or non-anonymous operation modes
\end{itemize}

\subsection{5. Design Considerations}\label{design-considerations}

\subsubsection{5.1. Performance
Optimisation}\label{performance-optimisation}

An implementation should prioritise:

\begin{itemize}
\tightlist
\item
  \textbf{minimal allocations}: Pre-allocated buffer reduces memory
  pressure
\item
  \textbf{efficient data structures}: Binary heap provides
  \codebubble{O(log n)} operations
\item
  \textbf{lock minimisation}: Fine-grained locking for concurrent access
\item
  \textbf{timer efficiency}: Single shared timer reduces system
  overhead, including minimising runtime system overhead by using a
  single thread
\end{itemize}

\subsubsection{5.2. Abuse Resistance and Resource
Limits}\label{abuse-resistance-and-resource-limits}

\begin{itemize}
\tightlist
\item
  \textbf{timing attacks}: Random delays must use cryptographically
  secure randomness
\item
  \textbf{statistical analysis}: Uniform distribution is a simple
  baseline; stronger timing strategies (e.g., exponential/Poisson as in
  Loopix {[}02{]}) provide better resistance to pattern inference
\item
  \textbf{queue bounds and DoS}: The mixer MUST use a bounded buffer
  with backpressure. Implementations MUST define behaviour when full
  (e.g., drop-tail oldest/newest, randomised drop, or reject upstream
  sends) and expose metrics/alerts to prevent memory exhaustion attacks.
\end{itemize}

\subsubsection{5.3. Monitoring and
Metrics}\label{monitoring-and-metrics}

The mixer should track:

\begin{itemize}
\tightlist
\item
  Current queue size
\item
  Average packet delay (over configurable window)
\end{itemize}

These metrics aid in:

\begin{itemize}
\tightlist
\item
  Performance tuning
\item
  Detecting abnormal traffic patterns
\item
  Capacity planning
\end{itemize}

\subsection{6. Security Considerations}\label{security-considerations}

\subsubsection{6.1. Threat Model}\label{threat-model}

The mixer defends against:

\begin{itemize}
\tightlist
\item
  \textbf{timing correlation attacks}: Randomised delays make linking
  input/output packets by timing significantly harder
\item
  \textbf{statistical traffic analysis}: Random delays reduce pattern
  predictability but do not eliminate all analysis
\item
  \textbf{queue manipulation}: Authenticated packet handling prevents
  injection attacks
\end{itemize}

\subsubsection{6.2. Limitations}\label{limitations}

The mixer does not protect against:

\begin{itemize}
\tightlist
\item
  \textbf{Low-volume spread traffic} that does not produce a sufficient
  number of messages to be mixed within the delay window
\item
  \textbf{Global passive adversaries} with unlimited observation
  capability
\item
  \textbf{active attacks}: packet dropping or delaying by malicious
  nodes
\item
  \textbf{side channels}: CPU, memory, or network-level information
  leaks
\end{itemize}

\subsection{7. Drawbacks}\label{drawbacks}

\begin{itemize}
\tightlist
\item
  \textbf{increased latency}: Every packet experiences additional delay
\item
  \textbf{memory usage}: Buffering packets requires memory proportional
  to traffic volume and queue size
\item
  \textbf{complexity}: Adds another component to the protocol stack,
  which even makes node-local debugging harder
\item
  \textbf{simplistic nature}: The mixing does not account for the total
  count of elements in the buffer. With increasing numbers of messages
  in the mixer, the generated delay can decrease without sacrificing the
  mixing properties.
\end{itemize}

\subsection{8. Alternatives}\label{alternatives}

Alternative mixing strategies considered:

\begin{itemize}
\tightlist
\item
  \textbf{batch mixing}: Release packets in fixed-size batches (higher
  latency)
\item
  \textbf{threshold mixing}: Release when buffer reaches a certain size
  (variable latency)
\item
  \textbf{stop-and-go mixing}: Fixed delays at each hop (predictable
  patterns)
\item
  \textbf{poisson mixing}: As implemented in Loopix {[}02{]}, uses
  Poisson-distributed delays that make real traffic harder to
  distinguish from cover traffic. This can provide stronger anonymity
  properties but requires careful parameter tuning and integration with
  cover traffic.
\end{itemize}

The current continuous mixing approach with uniform distribution is a
simple baseline that balances latency and anonymity while being easier
to implement and analyse.

\subsection{9. Unresolved Questions}\label{unresolved-questions}

\begin{itemize}
\tightlist
\item
  Optimal delay parameters for different network conditions
\item
  Adaptive delay strategies based on traffic patterns
\item
  Integration with node-local cover traffic generation
\item
  Memory usage limits and robust overflow handling strategies
\end{itemize}

\subsection{10. Future Work}\label{future-work}

\begin{itemize}
\tightlist
\item
  \textbf{poisson mixing implementation}: Implement Poisson mixing
  (exponentially distributed per-packet delays derived from a Poisson
  process) as described in Loopix {[}02{]} to provide stronger anonymity
  properties when combined with cover traffic
\item
  Performance optimizations for hardware acceleration
\end{itemize}

\subsection{11. References}\label{references}

{[}01{]} Bradner, S. (1997).
\href{https://datatracker.ietf.org/doc/html/rfc2119}{Key words for use
in RFCs to Indicate Requirement Levels}. \emph{IETF RFC 2119}.

{[}02{]} Piotrowska, A. M., Hayes, J., Elahi, T., Meiser, S., \&
Danezis, G. (2017). \href{https://arxiv.org/pdf/1703.00536.pdf}{The
Loopix Anonymity System}. \emph{26th USENIX Security Symposium},
1199-1216.
