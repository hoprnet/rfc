\section{RFC-0004 HOPR Packet
Protocol}\label{rfc-0004-hopr-packet-protocol}

\begin{itemize}
\tightlist
\item
  \textbf{RFC Number:} 0004
\item
  \textbf{Title:} HOPR Packet Protocol
\item
  \textbf{Status:} Draft
\item
  \textbf{Author(s):} Lukas Pohanka (@NumberFour8)
\item
  \textbf{Created:} 2025-03-19
\item
  \textbf{Updated:} 2025-08-27
\item
  \textbf{Version:} v0.9.0 (Draft)
\item
  \textbf{Supersedes:} N/A
\item
  \textbf{Related Links:}
  \href{../RFC-0002-mixnet-keywords/0002-mixnet-keywords.md}{RFC-0002},
  \href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005},
  \href{../RFC-0006-hopr-mixer/0006-hopr-mixer.md}{RFC-0006},
  \href{../RFC-0011-application-protocol/0011-application-protocol.md}{RFC-0011}
\end{itemize}

\subsection{1. Abstract}\label{1-abstract}

This RFC describes the wire format of a HOPR packet and its encoding and
decoding protocol. The HOPR packet format is heavily based on the Sphinx
packet format {[}01{]}, as it aims to fulfil the similiar set of goals:
to provide anonymous indistinguishable packets, hiding the path length
and unlinkability of messages. Moreover, the HOPR packet format adds
additional information to the header, which allows incentivization of
individual relay nodes via Proof of Relay.

The Proof of Relay (PoR) is described in the separate
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}.

\subsection{2. Introduction}\label{2-introduction}

The HOPR packet format is the fundamental building block of the HOPR
protocol, allowing to build the HOPR mixnet. The format is designed to
create indistinguishable packets sent between source and destination
using a set of relays over a path
\href{../RFC-0002-mixnet-keywords/0002-mixnet-keywords.md}{RFC-0002},
thereby achieving unlinkability of messages between sender and
destination. In HOPR protocol, the relays SHOULD also perform packet
mixing, as described in
\href{../RFC-0006-hopr-mixer/0006-hopr-mixer.md}{RFC-0006}. The format
is built using the Sphinx packet format {[}01{]} but adds additional
information for each hop to allow incentivization of the hops (except
the last one) for the relaying duties. The incentivization of the last
hop is exempt from the HOPR packet format itself and is subject to a
separate
\href{../RFC-0007-economic-reward-system/0007-economic-reward-system.md}{RFC-0007}.

The HOPR packet format does not require a reliable underlying transport
or in-order delivery. The packet payloads are encrypted, however,
payload authenticity and integrity is not assured and MAY be ensured by
the overlay protocol. In addition, the packet format is aimed to
minimize overhead and maximize payload capacity.

The HOPR packet consists of two primary parts:

\begin{itemize}
\item
  \emph{Meta packet} (also called the \emph{Sphinx packet}) that carries
  the necessary routing information for the selected path and the
  encrypted payload. This will be described in the following sections.
\item
  \emph{Ticket}, which contains payout (incentivization) information for
  the next hop on the path. The structure of Tickets is described in the
  separate
  \href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}.
\end{itemize}

\textbf{This document describes version 1.0.0 of the HOPR Packet format
and protocol.}

\subsubsection{2.1. Conventions and
terminology}\label{21-conventions-and-terminology}

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in
\href{https://datatracker.ietf.org/doc/html/rfc2119}{IETF RFC 2119}
when, and only when, they appear in all capitals, as shown here.

Terms defined in
\href{../RFC-0002-mixnet-keywords/0002-mixnet-keywords.md}{RFC-0002} are
used, as well as some following additional terms:

\emph{peer public/private key} (also \emph{pubkey} or \emph{privkey}):
part of a cryptographic key-pair owned by a peer.

\emph{extended path}: a forward or return path which in addition
contains the destination or sender respectively.

\emph{pseudonym}: a randomly generated identifier of the sender. The
pseudonym MAY be prefixed with a static prefix. The length such static
prefix MUST NOT exceed half of the entire pseudonym\textquotesingle s
size. The pseudonym used in the forward message MUST be the same as the
pseudonym used in the reply message.

\emph{public key identifier}: a reasonably short identifier of each
peer\textquotesingle s public key. The size of such an identifier SHOULD
be strictly smaller than the size of the corresponding public key.

\emph{\textbar x\textbar{}}: denotes the binary representation length of
\texttt{x} in bytes.

\subsubsection{2.2. Global packet format
parameters}\label{22-global-packet-format-parameters}

The HOPR packet format requires certain cryptographic primitives in
place, namely:

\begin{itemize}
\tightlist
\item
  an Elliptic Curve (EC) group where the Elliptic Curve Diffie-Hellman
  Problem (ECDLP) is hard. The peer public keys correspond to points on
  the chosen EC. The peer private keys correspond to scalars of the
  corresponding finite field.
\item
  Pseudo-Random Permutation (PRP), commonly represented by a symmetric
  cipher
\item
  Pseudo-Random Generator (PRG), commonly represented by a stream cipher
  or a block cipher in a stream-mode.
\item
  One-time authenticator \texttt{OA(K,\ M)} where K denotes a one-time
  key and M is the message being authenticated
\item
  a Key Derivation Function (KDF) allowing to:

  \begin{itemize}
  \tightlist
  \item
    generate secret key material from a high-entropy pre-key K, context
    string C, and a salt S: \texttt{KDF(C,\ K,\ S)}. KDF will perform
    the necessary expansion to match the size required by the output.
    The Salt \texttt{S} argument is optional and MAY be omitted.
  \item
    if the above is applied to an EC point as \texttt{K}, the point MUST
    be in its compressed form.
  \end{itemize}
\item
  Hash to Field (Scalar) operation \texttt{HS(S,T)} which computes a
  field element of the elliptic curve from
  \href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005},
  given the secret \texttt{S} and a tag \texttt{T}.
\end{itemize}

The concrete instantiations of these primitives are discussed in
Appendix 1. All the primitives MUST have corresponding security bounds
(e.g., they all have 128-bit security) and the generated key material
MUST also satisfy the required bounds of the primitives.

The global value of \texttt{PacketMax} is the maximum size of the data
in bytes allowed inside the packet payload.

\subsection{3. Forward packet creation}\label{3-forward-packet-creation}

The REQUIRED inputs for the packet creation are as follows:

\begin{itemize}
\tightlist
\item
  User\textquotesingle s Packet payload (as a sequence of bytes)
\item
  Sender pseudonym (as a sequence of bytes)
\item
  forward path and an OPTIONAL list of one or more return paths
\end{itemize}

The input MAY also contain:

\begin{itemize}
\tightlist
\item
  unique bidirectional map between peer pubkeys and public key
  identifiers (\emph{mapper})
\end{itemize}

Note that the mapper MAY only contain public key identifiers mappings of
pubkeys from forward and return paths.

The packet payload MUST be between 0 to \texttt{PacketMax} bytes-long.

The Sender pseudonym MUST be randomly generated for each packet header
but MAY contain a static prefix.

The forward and return paths MAY be represented by public keys of
individual hops. Alternatively, the paths MAY be represented by public
key identifiers and mapped using the mapper as needed.

The size of the forward and return paths (number of hops) MUST be
between 0 and 3.

\subsubsection{3.1. Partial Ticket
creation}\label{31-partial-ticket-creation}

The creation of the HOPR packet starts with the creation of the partial
Ticket structure as defined in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}. If
Ticket creation fails at this point, the packet creation process MUST be
terminated.

The Ticket is created almost completely, apart from the Challenge field,
which can be populated only after the Proof of Relay values have been
fully created for the packet.

\subsubsection{3.2. Generating the Shared
secrets}\label{32-generating-the-shared-secrets}

In the next step, shared secrets for individual hops on the forward path
are generated, as described in Section 2.2 in {[}01{]}:

Assume the length of the path is \texttt{N} (between 0 and 3) and each
hop\textquotesingle s public key is \texttt{Phop\_i}. The public key of
the destination is \texttt{Pdst}.

Let the extended path be a list of \texttt{Phop\_i} and \texttt{Pdst}
(for \texttt{i\ =\ 1\ ..\ N}). For \texttt{N\ =\ 0}, the extended path
consists of just \texttt{Pdst}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A new random ephemeral key pair is generated, \texttt{Epriv} and
  \texttt{Epub} respectively.
\item
  Set \texttt{Alpha} = \texttt{Epub} and \texttt{Coeff} = \texttt{Epriv}
\item
  For each (i-th) public key \texttt{P\_i} the Extended path:

  \begin{itemize}
  \tightlist
  \item
    \texttt{SharedPreSecret\_i} = \texttt{Coeff} * \texttt{P\_i}
  \item
    \texttt{SharedSecret\_i} = KDF("HASH\_KEY\_SPHINX\_SECRET",
    \texttt{SharedPreSecret\_i}, \texttt{P\_i})
  \item
    if \texttt{i\ ==\ N}, quit the loop
  \item
    \texttt{B\_i\ =\ KDF("HASH\_KEY\_SPHINX\_BLINDING",\ SharedPreSecret\_i,\ Alpha)}
  \item
    \texttt{Alpha\ =\ B\_i\ \textbackslash{}*\ Alpha}
  \item
    \texttt{Coeff\ =\ B\_i\ \textbackslash{}*\ Coeff}
  \end{itemize}
\item
  Return \texttt{Alpha} and the list of \texttt{SharedSecret\_i}
\end{enumerate}

For path of length \texttt{N}, the list length of the Shared secrets is
\texttt{N+1}.

In some instantiations, an invalid elliptic curve point may be
encountered anywhere during step 3. In such case the computation MUST
fail with an error. The process then MAY restart from step 1.

After
\texttt{KDF\_expand\textasciigrave{}\textasciigrave{},\ the\ }B\_i` MAY
be additionally transformed so that it conforms to a valid field scalar.
Shall that operation fail, the computation MUST fail with an error and
the process then MAY restart from step 1.

The returned \texttt{Alpha} value MAY be encoded to an equivalent
representation (such as using elliptic curve point compression), so that
space is preserved.

\subsubsection{3.3. Generating the Proof of
Relay}\label{33-generating-the-proof-of-relay}

The packet generation continues with per-hop proof generation of relay
values, Ticket challenge, and Acknowledgement challenge for the first
downstream node. This generation is done for each hop on the path.

This is described in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005} and
is a two-step process.

The first step uses the List of shared secrets for the extended path as
input. As a result, there is a list of length N, where each entry
contains:

\begin{itemize}
\tightlist
\item
  Ticket challenge for the hop i+1 on the extended path
\item
  Hint value for the i-th hop
\end{itemize}

Both values in each list entry are elliptic curve points. The Ticket
challenge value MAY be transformed via a one-way cryptographic hash
function, whose output MAY be truncated. See
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005} on
how such representation is instantiated.

This list consists of \texttt{PoRStrings\_i} entries.

In the second step of the PoR generation, the input is the first Shared
secret from the List and optionally the second Shared secret (if the
extended path is longer than 1). It outputs additional two entries:

\begin{itemize}
\tightlist
\item
  Acknowledgement challenge for the first hop
\item
  Ticket challenge for the first ticket
\end{itemize}

Also, here, both values are EC points, where the latter MAY be
represented via the same one-way representation.

This tuple is called \texttt{PoRValues} and is used to finalize the
partial Ticket: the Ticket challenge fills in the missing part in the
\texttt{Ticket}.

\subsubsection{3.4. Forward Meta Packet
creation}\label{34-forward-meta-packet-creation}

At this point, there is enough information to generate the Meta packet,
which is a logical construct that does not contain the \texttt{Ticket}
yet.

The Meta Packet consists of the following components:

\begin{itemize}
\tightlist
\item
  \texttt{Alpha} value
\item
  \texttt{Header} (an instantiation of the Sphinx mix header)
\item
  padded and encrypted payload \texttt{EncPayload}
\end{itemize}

The above order of these components is canonical MUST be followed when a
packet is serialized to its binary form. The definitions of the above
components follow in the next sections.

The \texttt{Alpha} value is obtained from the Shared secrets generation
phase.

The \texttt{Header} is created differently depending on whether this
packet is a forward packet or a reply packet.

The creation of the \texttt{EncPayload} depends on whether the packet is
routed via the forward path or return path.

\paragraph{3.4.1. Header creation}\label{341-header-creation}

The header creation also closely follows {[}01{]} Section 3.2. Its
creation is almost identical whether it is being created for the forward
or return path.

The input for the header creation is:

\begin{itemize}
\tightlist
\item
  Extended path (of peer public keys \texttt{P\_i})
\item
  Shared secrets from previous steps (\texttt{SharedSecret\_i})
\item
  PoRStrings (each entry denoted a \texttt{PoRString\_i} of equal
  lengths)
\item
  Sender pseudonym (represented as a sequence of bytes)
\end{itemize}

Let \texttt{HeaderPrefix\_i} be a single byte, where:

\begin{itemize}
\tightlist
\item
  The first 3 most significant bits indicate the version, and currently
  MUST be set to \texttt{001}.
\item
  The 4th most significant bit indicates the \texttt{NoAckFlag}. It MUST
  be set to 1 when the recipient SHOULD NOT acknowledge the packet.
\item
  The 5th most significant bit indicates the \texttt{ReplyFlag} and MUST
  be set to 1 if the header is created for the return path, otherwise it
  MUST be zero.
\item
  The last remaining 3 bits represent the number \texttt{i}, in
  \emph{most significant bits first} format.
\end{itemize}

For example, the binary representation of \texttt{HeaderPrefix\_3} with
\texttt{ReplyFlag} set and \texttt{NoAckFlag} not set looks like this:

\begin{verbatim}
HeaderPrefix_3 = 0 0 1 0 1 0 1 1
\end{verbatim}

The \texttt{HeaderPrefix\_i} MUST not be computed for
\texttt{i\ \textgreater{}\ 7}.

Let \texttt{ID\_i} be a public key identifier of \texttt{P\_i} (by using
the mapper), and \texttt{\textbar{}T\textbar{}} denote the
output\textquotesingle s size of a chosen one-time authenticator. Since
\texttt{ID\_i} MUST be all of equal lengths for each \texttt{i}, denote
this length \texttt{\textbar{}ID\textbar{}}. Similarly,
\texttt{\textbar{}PoRString\_i\textbar{}} MUST have also all equal
lengths of \texttt{\textbar{}PoRString\textbar{}}.

Let \texttt{RoutingInfoLen} be equal to
\texttt{1\ +\ \textbar{}ID\textbar{}\ +\ \textbar{}T\textbar{}\ +\ \textbar{}PoRString\textbar{}}.

Allocate a zeroized \texttt{HdrExt} buffer of
\texttt{1\ +\ \textbar{}Pseudonym\textbar{}\ +\ 4\ *\ RoutingInfoLen}
bytes and another zeroed buffer \texttt{OATag} of
\texttt{\textbar{}T\textbar{}} bytes.

For each i = 1 up to N+1 do:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initialize PRG with \texttt{SharedSecret\_\{N-i+2\}}
\item
  If i is equal to 1

  \begin{itemize}
  \tightlist
  \item
    Set \texttt{HdrExt{[}0{]}} to \texttt{HeaderPrefix\_0}
  \item
    Copy all bytes of \texttt{Pseudonym} to \texttt{HdrExt} at offset 1
  \item
    Fill \texttt{HdrExt} from offset
    \texttt{1\ +\ \textbar{}Pseudonym\textbar{}} up to
    \texttt{(5\ -\ N)\ *\ RoutingInfoLen} with uniformly randomly
    generated bytes.
  \item
    Perform an exclusive-OR (XOR) of bytes generated by the PRG with
    HdrExt, starting from offset 0 up to
    \texttt{1\ +\ \textbar{}Pseudonym\textbar{}\ +\ (5\ -\ N)\ *\ RoutingInfoLen}
  \item
    If N \textgreater{} 0, generate \emph{filler bytes} given the list
    of Shared secrets as follows:

    \begin{itemize}
    \tightlist
    \item
      Allocate a zeroed buffer Filler of \texttt{(N-1)*\ RoutingInfoLen}
    \item
      For each j from 1 to N-1:

      \begin{itemize}
      \tightlist
      \item
        Initialize a new PRG instance with \texttt{SharedSecret\_j}
      \item
        Seek the PRG to position
        \texttt{1\ +\ \textbar{}Pseudonym\textbar{}\ +\ (4\ -\ j)\ *\ RoutingInfoLen}
      \item
        XOR RoutingInfoLen bytes of the PRG to Filler from offset 0 up
        to \texttt{j\ *\ RoutingInfoLen}
      \item
        Destroy the PRG instance
      \end{itemize}
    \end{itemize}
  \item
    Copy the Filler bytes to \texttt{HdrExt} at offset
    \texttt{1\ +\ \textbar{}Pseudonym\textbar{}\ +\ (5\ -\ N)\ *\ RoutingInfoLen}
  \end{itemize}
\item
  If i is greater than 1:

  \begin{itemize}
  \tightlist
  \item
    Copy bytes of \texttt{HdrExt} from offset 0 up to
    \texttt{1\ +\ \textbar{}Pseudonym\textbar{}\ +\ 3\ *\ RoutingInfoLen}
    to offset \texttt{RoutingInfoLen} in \texttt{HdrExt}
  \item
    Set \texttt{HdrExt{[}0{]}} to \texttt{HeaderPrefix\_\{i-1\}}
  \item
    Copy \texttt{ID\_\{N-i+2\}} to \texttt{HdrExt} starting at offset 1
  \item
    Copy \texttt{OATag} to \texttt{HdrExt} starting at offset
    \texttt{1\ +\ \textbar{}ID\textbar{}}
  \item
    Copy bytes of \texttt{PoRString\_\{N-i+2\}} to \texttt{HdrExt}
    starting at offset
    \texttt{1\ +\ \textbar{}ID\textbar{}\ +\ \textbar{}T\textbar{}}
  \item
    XOR PRG bytes to \texttt{HdrExt} from offset 0 up to
    \texttt{1\ +\ \textbar{}Pseudonym\textbar{}\ +\ 3\ *\ RoutingInfoLen}
  \end{itemize}
\item
  Compute \texttt{K\_tag} = KDF("HASH*KEY\_TAG",
  \texttt{SharedSecret*\{N-i+2\}})
\item
  Compute
  \texttt{OA(K\_tag,\ HdrExt{[}0\ ..\ 1\ +\ \textbar{}Pseudonym\textbar{}\ +\ 3\ *\ RoutingInfoLen)}
  and copy its output of \texttt{\textbar{}T\textbar{}} bytes to
  \texttt{OATag}
\end{enumerate}

The output is the contents of \texttt{HdrExt} from offset 0 up to
\texttt{1\ +\ \textbar{}Pseudonym\textbar{}\ +\ 3\ *\ RoutingInfoLen}
and the \texttt{OATag}:

\begin{verbatim}
Header {
  header: [u8; 1 + |Pseudonym| + 3 * RoutingInfoLen]
  oa_tag: [u8; |T|]
}
\end{verbatim}

\paragraph{3.4.2. Forward payload
creation}\label{342-forward-payload-creation}

The packet payload consists of the User payload given at the beginning
of section 2. However, if any non-zero number of return paths has been
given as well, the packet payload MUST consist of that many Single Use
Reply Blocks (SURBs) that are prepended to the User payload.

The total size of the packet payload MUST not exceed \texttt{PacketMax}
bytes, and therefore the size of the User payload and the number of
SURBs is bounded.

A packet MAY only contain SURBs and no User payload. There MUST NOT be
more than 15 SURBs in a single packet. The packet MAY contain additional
packet signals for the recipient, typically the upper 4 bits of the SURB
count field MAY serve this purpose.

For the above reasons, the forward payload MUST consist of:

\begin{itemize}
\tightlist
\item
  the number of SURBs
\item
  all SURBs (if the number was non-zero)
\item
  User\textquotesingle s payload
\end{itemize}

\begin{verbatim}
PacketPayload {
  signals: u4,
  num_surbs: u4,
  surbs: [Surb; num_surbs]
  user_payload: [u8; <variable length>]
}
\end{verbatim}

The \texttt{signals} and \texttt{num\_surbs} fields MAY be encoded as a
single byte, where the most-significant 4 bits represent the
\texttt{signals} and the least-significant 4 bits represent the
\texttt{num\_surbs}. When no signals are passed, the \texttt{signals}
field MUST be zero.

The user payload usually consists of the Application layer protocol as
described in
\href{../RFC-0011-application-protocol/0011-application-protocol.md}{RFC-0011},
but it can be arbitrary.

\paragraph{3.4.3. Generating SURBs}\label{343-generating-surbs}

The Single Use Reply Block is always generated by the Sender for its
chosen pseudonym. Its purpose is to allow reply packet generation sent
on the return path from the recipient back to sender.

The process of generating a single SURB is very similar to the process
of creating the forward packet header.

As \texttt{SURB} is sent to the packet recipient, it also has its
counterpart, called \texttt{ReplyOpener}. The \texttt{ReplyOpener} is
generated alongside the SURB and is stored at the Sender (indexed by its
Pseudonym) and used later to decrypt the reply packet delivered to the
Sender using the associated SURB.

Both \texttt{SURB} and the \texttt{ReplyOpener} are always bound to the
chosen Sender pseudonym.

Inputs for creating a \texttt{SURB} and the \texttt{ReplyOpener}:

\begin{itemize}
\tightlist
\item
  return path
\item
  sender pseudonym
\end{itemize}

OPTIONALLY, also a unique bidirectional map between peer pubkeys and
public key identifiers (\emph{mapper}) is given.

The generation of \texttt{SURB} and its corresponding
\texttt{ReplyOpener} is as follows:

Assume the length of the return path is N (between 0 and 3) and each
hop\textquotesingle s public key is \texttt{Phop\_i}. The public key of
the sender is \texttt{Psrc}.

Let the extended return path be a list of \texttt{Phop\_i} and
\texttt{Psrc} (for i = 1 .. N). For N = 0, the Extended return path
consists of just \texttt{Psrc}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  generate a Shared secret list (\texttt{SharedSecret\_i}) for the
  extended return path and the corresponding \texttt{Alpha} value as
  given in section 3.2.
\item
  generate PoR for the given extended return path: list of
  \texttt{PoRStrings\_i} and \texttt{PoRValues}
\item
  generate Reply packet \texttt{Header} for the extended return path as
  in section 3.4.1:

  \begin{itemize}
  \tightlist
  \item
    The list of \texttt{PoRStrings\_i} and list of
    \texttt{SharedSecret\_i} from step 1 and 2 are used
  \item
    The 5th bit of the \texttt{HeaderPrefix} is set to 1 (see section
    3.4.1)
  \end{itemize}
\item
  generate a random cryptographic key material, for at least the
  selected security boundary (\texttt{SenderKey} as a sequence of bytes)
\end{enumerate}

\texttt{SURB} MUST consist of:

\begin{itemize}
\tightlist
\item
  \texttt{SenderKey}
\item
  \texttt{Header} (for the return path)
\item
  public key identifier of the first return path hop
\item
  \texttt{PoRValues}
\item
  \texttt{Alpha} value (for the return path)
\end{itemize}

\begin{verbatim}
SURB {
  alpha: Alpha,
  header: Header,
  sender_key: [u8; <variable length>]
  first_hop_ident: [u8; <variable length>]
  por_values: PoRValues
}
\end{verbatim}

The corresponding \texttt{ReplyOpener} MUST consist of:

\begin{itemize}
\tightlist
\item
  \texttt{SenderKey}
\item
  Shared secret list (\texttt{SharedSecret\_i})
\end{itemize}

\begin{verbatim}
ReplyOpener {
  sender_key: [u8; <variable length>]
  rp_shared_secrets: [SharedSecret; N+1]
}
\end{verbatim}

The Sender keeps the \texttt{ReplyOpener} (MUST be indexed by the chosen
pseudonym), and puts the \texttt{SURB} in the forward packet payload.

\paragraph{3.4.4. Payload padding}\label{344-payload-padding}

The packet payload MUST be padded in accordance to {[}01{]} to exactly
\texttt{PacketMax\ +\ \textbar{}PaddingTag\textbar{}} bytes.

The process works as follows:

The payload MUST always be pre-pended with a \texttt{PaddingTag}. The
\texttt{PaddingTag} SHOULD be 1 byte long.

If the length of the payload is still less than
\texttt{PacketMax\ +\ \textbar{}PaddingTag\textbar{}} bytes, zero bytes
MUST be prepended until the length is exactly
\texttt{PacketMax\ +\ \textbar{}PaddingTag\textbar{}} bytes.

\begin{verbatim}
PaddedPayload {
  zeros: [0u8; PacketMax - |PacketPayload|],
  padding_tag: u8,
  payload: PacketPayload
}
\end{verbatim}

\paragraph{3.4.5. Payload encryption}\label{345-payload-encryption}

The encryption of the padded payload follows the same procedure from
{[}01{]}.

For each i=1 up to N:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Generate \texttt{Kprp} = KDF("HASH\_KEY\_PRP",
  \texttt{SharedSecret\_i})
\item
  Transform the \texttt{PaddedPayload} using PRP:
\end{enumerate}

\begin{verbatim}
EncPayload = PRP(Kprp, PaddedPayload)
\end{verbatim}

The Meta packet is formed from \texttt{Alpha}, \texttt{Header}, and
\texttt{EncPayload}.

\subsubsection{3.5. Final forward packet
overview}\label{35-final-forward-packet-overview}

The final structure of the HOPR packet format MUST consist of the
logical Meta packet with the \texttt{Ticket} attached:

\begin{verbatim}
HOPR_Packet {
  alpha: Alpha,
  header: Header,
  encrypted_payload: EncPayload,
  ticket: Ticket
}
\end{verbatim}

The packet is then sent to the peer represented by the first public key
of the forward path.

Note that the size of the packet is exactly
\texttt{\textbar{}HOPR\_Packet\textbar{}\ =\ \textbar{}Alpha\textbar{}\ +\ \textbar{}Header\textbar{}\ +\ \textbar{}PacketMax\textbar{}\ +\ \textbar{}PaddingTag\textbar{}\ +\ \textbar{}Ticket\textbar{}}.
It can be also referred to the size of the logical Meta packet plus
\texttt{\textbar{}Ticket\textbar{}}.

\subsection{4. Reply packet creation}\label{4-reply-packet-creation}

Upon receiving a forward packet, the forward packet recipient SHOULD
create a reply packet using one of a SURB. This is possible only if the
Recipient received a SURB (with this or any previous forward packets)
from an equal pseudonym.

The Recipient MAY use any SURB with the same pseudonym; however, in such
a case the SURBs MUST be used in the reverse order in which they were
received.

The Sender of the forward packet MAY use a fixed random prefix of the
pseudonym to identify itself across multiple forward packets. In such a
case, the SURBs indexed with pseudonyms with the same prefix SHOULD be
used in random order to construct reply packets.

The following inputs are REQUIRED to create the reply packet:

\begin{itemize}
\tightlist
\item
  User\textquotesingle s Packet payload (as a sequence of bytes)
\item
  Pseudonym of the forward packet sender
\item
  Single Use Reply Block (\texttt{SURB}) corresponding to the above
  pseudonym
\end{itemize}

OPTIONALLY, a unique bidirectional map between peer pubkeys and public
key identifiers (\emph{mapper}) is also given.

The final reply packet is a \texttt{HOPR\_Packet} and the means of
getting the values needed for its construction are given in the next
sections.

\subsubsection{4.1. Reply packet ticket
creation}\label{41-reply-packet-ticket-creation}

The \texttt{PoRValues} and first reply hop key identifiers are extracted
from the used \texttt{SURB}.

The mapper is used to map the key identifier
(\texttt{first\_hop\_ident}) to the public key of the first reply hop,
which is then used to retrieve required ticket information.

The Challenge from the \texttt{PoRValues} (\texttt{por\_values}) in the
\texttt{SURB} is used to construct the complete \texttt{Ticket} for the
first hop.

\subsubsection{4.2. Reply meta packet
creation}\label{42-reply-meta-packet-creation}

The \texttt{Alpha} value (\texttt{alpha} field) and the packet
\texttt{Header} (\texttt{header} field) are extracted from the used
\texttt{SURB}.

\paragraph{4.2.1. Reply payload
creation}\label{421-reply-payload-creation}

The reply payload is constructed as \texttt{PacketPayload} in section
3.4.2. However, the reply payload MUST not contain any SURBs.

\begin{verbatim}
PacketPayload {
  signals: u4,
  num_surbs: u4,   // = zero
  surbs: [Surb; 0] // empty
  user_payload: [u8; <variable length>]
}
\end{verbatim}

The \texttt{PacketPayload} then MUST be padded to get
\texttt{PaddedPayload} as described in section 3.4.4.

\paragraph{4.2.2. Reply payload
encryption}\label{422-reply-payload-encryption}

The \texttt{SenderKey} (\texttt{sender\_key} field) is extracted from
the used \texttt{SURB}.

The \texttt{PaddedPayload} of the reply packet MUST be encrypted as
follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Generate \texttt{Kprp\_reply} = KDF("HASH\_KEY\_REPLY\_PRP",
  \texttt{SenderKey}, \texttt{Pseudonym})
\item
  Transform the \texttt{PaddedPayload} as using PRP:
\end{enumerate}

\begin{verbatim}
EncPayload = PRP(Kprp_reply, PaddedPayload)
\end{verbatim}

This finalizes all the fields of the \texttt{HOPR\_Packet} of for the
reply. The \texttt{HOPR\_Packet} is sent to the peer represented by a
public key, corresponding to \texttt{first\_hop\_ident} extracted from
the \texttt{SURB} (that is the first peer on the return path). For this
operation, the mapper MAY be used to get the actual public key to route
the packet.

\subsection{5. Packet processing}\label{5-packet-processing}

This section describes the behavior of processing a
\texttt{HOPR\_Packet} instance, when received by a peer (hop). Let
\texttt{Phop\_priv} be the private key corresponding to the public key
\texttt{Phop} of the peer processing the packet.

Upon reception of a byte-sequence that is at least
\texttt{\textbar{}HOPR\_Packet\textbar{}} bytes-long, the
\texttt{\textbar{}Ticket\textbar{}} is separated from the sequence. As
per section 2.4, the order of the fields in \texttt{HOPR\_Packet} is
canonical, thefore the \texttt{Ticket} starts exactly at
\textbar HOPR\_Packet\textbar{} - \textbar Ticket\textbar{} byte-offset.

The resulting Meta packet is processed first, and if this processing is
successful, the \texttt{Ticket} is validated as well, as defined in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}.

If any of the operations fail, the packet MUST be rejected, and
subsequently, it MUST be acknowledged. See Section 5.4.

\subsubsection{5.1. Advancing the Alpha
value}\label{51-advancing-the-alpha-value}

To recover the \texttt{SharedSecret\_i}, the \texttt{Alpha} value MUST
be transformed using the following transformation:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compute \texttt{SharedPreKey\_i} = \texttt{Phop\_priv} *
  \texttt{Alpha}
\item
  \texttt{SharedSecret\_i} = KDF("HASH\_KEY\_SPHINX\_SECRET",
  \texttt{SharedPreKey\_i}, \texttt{Phop})
\item
  \texttt{B\_i} = KDF("HASH\_KEY\_SPHINX\_BLINDING",
  \texttt{SharedPreKey\_i}, \texttt{Alpha})
\item
  \texttt{Alpha} = \texttt{B\_i} * \texttt{Alpha}
\end{enumerate}

Similarly, as in section 3.2, the \texttt{B\_i} in step 3 MAY be
additionally transformed so that it conforms to a valid field scalar
usable in step 4.

Shall the process fail in any of these steps (due to invalid EC point or
field scalar), the process MUST terminate with an error and the entire
packet MUST be rejected.

Also derive the \texttt{ReplayTag} = KDF("HASH\_KEY\_PACKET\_TAG",
\texttt{SharedSecret\_i}). Verify that \texttt{ReplayTag} has not yet
been seen by this node, and if yes, the packet MUST be rejected.

\subsubsection{5.2. Header processing}\label{52-header-processing}

In the next steps, the \texttt{Header} (field \texttt{header}) processed
using the derived \texttt{SharedSecret\_i} .

As per section 3.4.1, the \texttt{Header} consists of two byte sequences
of fixed length: the \texttt{header} and \texttt{oa\_tag}. Let
\textbar T\textbar{} be the fixed byte-length of \texttt{oa\_tag} and
\textbar Header\textbar{} be the fixed byte-length of \texttt{header}.
Also denote \textbar PoRString\_i\textbar, which have equal for all
\texttt{i}, as \textbar PoRString\textbar. Likewise,
\textbar ID\_i\textbar{} for all \texttt{i} as \textbar ID\textbar.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Generate \texttt{K\_tag} = KDF("HASH\_KEY\_TAG", 0,
  \texttt{SharedSecret\_i})
\item
  Compute \texttt{oa\_tag\_c} = OA(\texttt{K\_tag}, \texttt{header})
\item
  If \texttt{oa\_tag\_c} != \texttt{oa\_tag}, the entire packet MUST be
  rejected.
\item
  Initialize PRG with \texttt{SharedSecret\_i} and XOR PRG bytes to
  \texttt{header}
\item
  The first byte of the transformed \texttt{header} represents the
  \texttt{HeaderPrefix}:

  \begin{itemize}
  \tightlist
  \item
    Verify that the first 3 most significant bits represent the
    supported version (\texttt{001}), otherwise the entire packet MUST
    be rejected.
  \item
    If 3 least significant bits are not all zeros (meaning this node not
    the recipient):

    \begin{itemize}
    \tightlist
    \item
      Let \texttt{i} be the 3 least significant bits of
      \texttt{HeaderPrefix}
    \item
      Set \texttt{ID\_i} =
      \texttt{header{[}\textbar{}HeaderPrefix\textbar{}..\textbar{}HeaderPrefix\textbar{}\ +\ \textbar{}ID\textbar{}}{]}
    \end{itemize}
  \item
    \texttt{Tag\_i} =
    \texttt{header{[}\textbar{}HeaderPrefix\textbar{}\ +\ \textbar{}ID\textbar{}\ ..\ \textbar{}HeaderPrefix\textbar{}\ +\ \textbar{}ID\textbar{}\ +\ \textbar{}T\textbar{}{]}}
  \item
    \texttt{PoRString\_i} =
    \texttt{header{[}\textbar{}HeaderPrefix\textbar{}+\ \textbar{}ID\textbar{}\ +\ \textbar{}T\textbar{}..\textbar{}HeaderPrefix\textbar{}\ +\ \textbar{}ID\textbar{}\ +\ \textbar{}PoRString\textbar{}{]}}
  \item
    Shift \texttt{header} by
    \texttt{\textbar{}HeaderPrefix\textbar{}\ +\ \textbar{}ID\textbar{}\ +\ \textbar{}T\textbar{}\ ..\ \textbar{}HeaderPrefix\textbar{}\ +\ \textbar{}ID\textbar{}\ +\ \textbar{}PoRString\textbar{}}
    bytes left (discarding those bytes)
  \item
    Seek the PRG to the position \texttt{\textbar{}Header\textbar{}}
  \item
    Apply the PRG keystream to \texttt{header}
  \item
    Otherwise, if all 3 least significant bits are all zeroes, it means
    this node is the recipient:

    \begin{itemize}
    \tightlist
    \item
      Recover \texttt{pseudonym} as
      \texttt{header{[}\textbar{}HeaderPrefix\textbar{}\ ..\ \textbar{}HeaderPrefix\textbar{}\ +\ \textbar{}Pseudonym\textbar{}{]}}
    \item
      Recover the 5th and 4th most significant bit (\texttt{NoAckFlag}
      and \texttt{ReplyFlag})
    \end{itemize}
  \end{itemize}
\end{enumerate}

\subsubsection{5.3. Packet processing}\label{53-packet-processing}

In the next step, the \texttt{encrypted\_payload} is decrypted:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Generate \texttt{Kprp} = KDF("HASH\_KEY\_PRP",
  \texttt{SharedSecret\_i})
\item
  Transform the \texttt{encrypted\_payload} using PRP:
\end{enumerate}

\begin{verbatim}
new_payload = PRP(Kprp, encrypted_payload)
\end{verbatim}

\paragraph{5.3.1. Forwarded packet}\label{531-forwarded-packet}

If the processed header indicated that the packet is destined for
another node, the \texttt{new\_payload} is the
\texttt{encrypted\_payload:\ EncryptedPayload} . The updated
\texttt{header} and \texttt{alpha} values from the previous steps are
used to construct the forwarded packet. A new \texttt{ticket} structure
is created for the recipient (as described in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}),
while the current \texttt{ticket} structure MUST be verified (as also
described in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}).

The forwarded packet MUST have the identical structure :

\begin{verbatim}
HOPR_Packet {
  alpha: Alpha,
  header: Header,
  encrypted_payload: EncPayload,
  ticket: Ticket
}
\end{verbatim}

\paragraph{5.3.2. Final packet}\label{532-final-packet}

If the processed header indicated that this node is the final
destination of the packet, the \texttt{ReplyFlag} is used to indicate
subsequent processing.

\subparagraph{5.3.2.1. Forward packet}\label{5321-forward-packet}

If the \texttt{ReplyFlag} is set to 0, the packet is a forward (not a
reply) packet.

The \texttt{new\_payload} MUST be the \texttt{PaddedPayload}.

\subparagraph{5.3.2.2. Reply packet}\label{5322-reply-packet}

If the \texttt{ReplyFlag} is set to 1, it indicates that this is a reply
packet that requires further processing. The \texttt{pseudonym}
extracted during header processing is used to find the corresponding
\texttt{ReplyOpener}. If it is not found, the packet MUST be rejected.

Once the \texttt{ReplyOpener} is found, the \texttt{rp\_shared\_secrets}
are used to decrypt the \texttt{new\_payload}:

For each \texttt{SharedSecret\_k} in \texttt{rp\_shared\_secrets} do:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Generate \texttt{Kprp} = KDF("HASH\_KEY\_PRP",
  \texttt{SharedSecret\_k})
\item
  Transform the \texttt{new\_payload} using PRP:
\end{enumerate}

\begin{verbatim}
new_payload = PRP(Kprp, new_payload)
\end{verbatim}

This will invert the PRP transformations done at each forwarding hop.
Finally, the additional reply PRP transformation has to be inverted
(using \texttt{sender\_key} from the \texttt{ReplyOpener} and
\texttt{pseudonym} ):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Generate \texttt{Kprp\_reply} = KDF("HASH\_KEY\_REPLY\_PRP",
  \texttt{sender\_key}, \texttt{pseudonym})
\item
  Transform the \texttt{new\_payload} as using PRP:
\end{enumerate}

\begin{verbatim}
new_payload = PRP(Kprp_reply, new_payload)
\end{verbatim}

The \texttt{new\_payload} now MUST be \texttt{PaddedPayload}.

\paragraph{5.3.3. Interpreting the
payload}\label{533-interpreting-the-payload}

In any case, the \texttt{new\_payload} is \texttt{PaddedPayload}.

The \texttt{zeros} are removed until the \texttt{padding\_tag} is found.
If it cannot be found, the packet MUST be rejected. The
\texttt{payload:\ PacketPayload} is extracted. If \texttt{num\_surbs}
\textgreater{} 0, the contained SURBs SHOULD be stored to be used for
future reply packet creation, indexed by the \texttt{pseudonym}
extracted during header processing.

The \texttt{user\_payload} can then be used by the upper protocol layer.

\subsubsection{5.4. Ticket verification and
acknowledgement}\label{54-ticket-verification-and-acknowledgement}

In the next step the \texttt{ticket} MUST be pre-verified using the
\texttt{SharedSecret\_i}, as defined in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}. If
the packet was not destined for this node (not final) OR the packet is
final and the \texttt{NoAckFlag} is 0, the packet MUST be acknowledged.

The acknowledgement of the successfully processed packet is created as
per \href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}
using \texttt{SharedKey\_i+1\_ack} =
\texttt{HS(SharedSecret\_i,\ "HASH\_ACK\_KEY")}. The
\texttt{SharedKey\_i+1\_ack} is the scalar in the field of the elliptic
curve chosen in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}. The
acknowledgement is sent back to the previous hop.

This is done creating and sending a standard forward packet directly to
the node the original packet was received from. The \texttt{NoAckFlag}
on this packet MUST be set. The \texttt{user\_payload} of the packet
contains the encoded \texttt{Acknowledgement} structure as defined in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}. The
\texttt{num\_surbs} of this packet MUST be set to 0.

If the packet processing was not successful at any point, a random
acknowledgement MUST be generated (as defined in
\href{../RFC-0005-proof-of-relay/0005-proof-of-relay.md}{RFC-0005}) and
sent to the previous hop.

\subsection{6. Appendix A}\label{6-appendix-a}

The current version is instantiated using the following cryptographic
primitives:

\begin{itemize}
\tightlist
\item
  Curve25519 elliptic curve with the corresponding scalar field
\item
  PRP is instantiated using Lioness wide-block cipher {[}04{]} over
  Chacha20 and Blake3
\item
  PRG is instantiated using Chacha20 {[}02{]}
\item
  OA is instantiated with Poly1305 {[}02{]}
\item
  KDF is instantiated using Blake3 in KDF mode, where the optional salt
  \texttt{S} is prepended to the key material \texttt{K}:
  \texttt{KDF(C,K,S)\ =\ blake3\_kdf(C,\ S\ \textbar{}\textbar{}\ K)}.
  If \texttt{S} is omitted: \texttt{KDF(C,K)\ =\ blake3\_kdf(C,K)}.
\item
  HS is instantiated via \texttt{hash\_to\_field} using
  \texttt{secp256k1\_XMD:SHA3-256\_SSWU\_RO\_} as defined in {[}02{]}.
  \texttt{S} is used a the secret input, and \texttt{T} as an additional
  domain separator.
\end{itemize}

\subsection{7. References}\label{7-references}

{[}01{]} Danezis, G., \& Goldberg, I. (2009).
\href{https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf}{Sphinx: A
Compact and Provably Secure Mix Format}. \emph{2009 30th IEEE Symposium
on Security and Privacy}, 262-277.

{[}02{]} Nir, Y., \& Langley, A. (2015).
\href{https://www.rfc-editor.org/rfc/rfc7539.html}{ChaCha20 and Poly1305
for IETF Protocols}. \emph{IETF RFC 7539}.

{[}03{]} Faz-Hernandez, A., et al. (2023).
\href{https://www.rfc-editor.org/rfc/rfc9380.html}{Hashing to Elliptic
Curves}. \emph{IETF RFC 9380}.

{[}04{]} Anderson, R., \& Biham, E. (1996). Two practical and provably
secure block ciphers: BEAR and LION. \emph{In International Workshop on
Fast Software Encryption (pp. 113-120). Berlin, Heidelberg: Springer
Berlin Heidelberg.}
